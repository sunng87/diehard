<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>diehard.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Diehard</span> <span class="project-version">0.7.2-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>diehard</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>diehard</span></div></div></li><li class="depth-2 branch"><a href="diehard.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-2 branch"><a href="diehard.circuit-breaker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>circuit-breaker</span></div></a></li><li class="depth-2 branch current"><a href="diehard.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="diehard.rate-limiter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rate-limiter</span></div></a></li><li class="depth-2"><a href="diehard.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="diehard.core.html#var-*elapsed-time-ms*"><div class="inner"><span>*elapsed-time-ms*</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-*executions*"><div class="inner"><span>*executions*</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-*start-time-ms*"><div class="inner"><span>*start-time-ms*</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-defbulkhead"><div class="inner"><span>defbulkhead</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-defcircuitbreaker"><div class="inner"><span>defcircuitbreaker</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-deflistener"><div class="inner"><span>deflistener</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-defratelimiter"><div class="inner"><span>defratelimiter</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-defretrypolicy"><div class="inner"><span>defretrypolicy</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-with-bulkhead"><div class="inner"><span>with-bulkhead</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-with-circuit-breaker"><div class="inner"><span>with-circuit-breaker</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-with-rate-limiter"><div class="inner"><span>with-rate-limiter</span></div></a></li><li class="depth-1"><a href="diehard.core.html#var-with-retry"><div class="inner"><span>with-retry</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">diehard.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-*elapsed-time-ms*"><h3>*elapsed-time-ms*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Available in retry block. Contexual value represents time elasped since first attempt</p></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L67">view source</a></div></div><div class="public anchor" id="var-*executions*"><h3>*executions*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Available in retry block. Contexual value represents execution times</p></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L70">view source</a></div></div><div class="public anchor" id="var-*start-time-ms*"><h3>*start-time-ms*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Available in retry block. Contexual value represents first attempt time</p></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L73">view source</a></div></div><div class="public anchor" id="var-defbulkhead"><h3>defbulkhead</h3><h4 class="type">macro</h4><div class="usage"><code>(defbulkhead name opts)</code></div><div class="doc"><div class="markdown"><p>Create bulkhead config from option map. * <code>concurrency</code> the max number of concurrent executions</p></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L484">view source</a></div></div><div class="public anchor" id="var-defcircuitbreaker"><h3>defcircuitbreaker</h3><h4 class="type">macro</h4><div class="usage"><code>(defcircuitbreaker name opts)</code></div><div class="doc"><div class="markdown"><p>Define a circuit breaker with option.</p>
<h4><a href="#available-options" name="available-options"></a>Available options</h4>
<p>There options are available when creating circuit breaker in <code>defcircuitbreaker</code>.</p>
<h5><a href="#failure-criteria" name="failure-criteria"></a>Failure criteria</h5>
<p>All the three <code>fail</code> options share same meaning with similar option in retry block.</p>
<ul>
  <li><code>:fail-if</code></li>
  <li><code>:fail-on</code></li>
  <li><code>:fail-when</code></li>
  <li><code>:timeout-ms</code> while give all you code a timeout is best practice in  application level, circuit breaker also provides a timeout for  marking a long running block as failure</li>
</ul>
<h5><a href="#delay-and-threshold" name="delay-and-threshold"></a>Delay and threshold</h5>
<ul>
  <li><code>:delay-ms</code> required. the delay for <code>:open</code> circuit breaker to turn  into <code>:half-open</code>.</li>
  <li><code>:failure-threshold</code></li>
  <li><code>:failure-threshold-ratio</code></li>
  <li><code>:success-threshold</code></li>
  <li><code>:success-threshold-ratio</code> All these four option is to determine at  what condition the circuit breaker is open.</li>
</ul>
<h5><a href="#listeners" name="listeners"></a>Listeners</h5>
<ul>
  <li><code>:on-open</code> a function to be called when state goes <code>:open</code></li>
  <li><code>:on-close</code> a function to be called when state goes <code>:closed</code></li>
  <li><code>:on-half-open</code> a function to be called when state goes <code>:half-open</code></li>
</ul></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L342">view source</a></div></div><div class="public anchor" id="var-deflistener"><h3>deflistener</h3><h4 class="type">macro</h4><div class="usage"><code>(deflistener name opts)</code></div><div class="doc"><div class="markdown"><p>Predefined listener.</p>
<h5><a href="#retry-listeners" name="retry-listeners"></a>Retry Listeners</h5>
<ul>
  <li><code>:on-abort</code> accepts a function which takes <code>result</code>, <code>exception</code> as  arguments, called when retry aborted</li>
  <li><code>:on-complete</code> accepts a function which takes <code>result</code>, <code>exception</code> as  arguments, called when exiting <code>retry</code> block</li>
  <li><code>:on-failed-attempt</code> accepts a function which takes <code>result</code>,  <code>exception</code> as arguments, called when execution failed (matches  retry criteria)</li>
  <li><code>:on-failure</code> accepts a function which takes <code>result</code>,  <code>exception</code> as arguments, called when existing <code>retry</code> block with  failure (matches retry criteria)</li>
  <li><code>:on-success</code> accepts a function which takes <code>result</code> as arguments,  called when existing <code>retry</code> block with success (mismatches retry  criteria)</li>
  <li><code>:on-retry</code> accepts a function which takes <code>result</code> as arguments,  called when a retry attempted.</li>
</ul>
<h5><a href="#use-predefined-listeners" name="use-predefined-listeners"></a>Use predefined listeners</h5>
<pre><code class="clojure">(diehard/deflistener listener
  {:on-retry (fn [return-value exception-thrown] (println "retried"))})

(diehard/with-retry {:policy policy :listener listener}
  ;; your code here
  )
</code></pre></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L173">view source</a></div></div><div class="public anchor" id="var-defratelimiter"><h3>defratelimiter</h3><h4 class="type">macro</h4><div class="usage"><code>(defratelimiter name opts)</code></div><div class="doc"><div class="markdown"><p>Create a rate limiter with options.</p>
<ul>
  <li><code>:rate</code> execution permits per second.</li>
  <li><code>:max-cached-tokens</code> the max size of permits we can cache when idle</li>
</ul></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L423">view source</a></div></div><div class="public anchor" id="var-defretrypolicy"><h3>defretrypolicy</h3><h4 class="type">macro</h4><div class="usage"><code>(defretrypolicy name opts)</code></div><div class="doc"><div class="markdown"><p>Predefined retry policy.</p>
<h4><a href="#available-options" name="available-options"></a>Available options</h4>
<h5><a href="#retry-criteria" name="retry-criteria"></a>Retry criteria</h5>
<ul>
  <li><code>:retry-when</code> retry when return value is given value</li>
  <li><code>:retry-on</code> retry on given exception / exceptions(vector) were thrown</li>
  <li><code>:retry-if</code> specify a function <code>(fn [return-value
  exception-thrown])</code>, retry if the function returns true</li>
</ul>
<h5><a href="#retry-abortion-criteria" name="retry-abortion-criteria"></a>Retry abortion criteria</h5>
<ul>
  <li><code>:abort-when</code> abort retry when return value is given value</li>
  <li><code>:abort-on</code> abort retry on given exception / exceptions(vector) were  thrown</li>
  <li><code>:abort-if</code> specify a function <code>(fn [return-value
  exception-thrown])</code>, abort retry if the function returns true</li>
  <li><code>:max-retries</code> abort retry when max attempts reached</li>
  <li><code>:max-duration</code> abort retry when duration reached</li>
</ul>
<h5><a href="#delay" name="delay"></a>Delay</h5>
<ul>
  <li><code>:backoff-ms</code> specify a vector <code>[initial-delay-ms max-delay-ms
  multiplier]</code> to control the delay between each retry, the delay for  <strong>n</strong>th retry will be <code>(max (* initial-delay-ms n) max-delay-ms)</code></li>
  <li><code>:delay-ms</code> use constant delay between each retry</li>
  <li><code>:jitter-factor</code> random factor for each delay</li>
  <li><code>:jitter-ms</code> random time <code>(-jitter-ms, jitter-ms)</code> adds to each delay</li>
</ul>
<h5><a href="#use-pre-defined-policy" name="use-pre-defined-policy"></a>Use pre-defined policy</h5>
<p>You can put together all those retry policies in a <code>defretrypolicy</code>. And use <code>:policy</code> option in option map.</p>
<pre><code class="clojure">(diehard/defretrypolicy policy
  {:max-retries 5
   :backoff-ms [1000 10000]})

(diehard/with-retry {:policy policy}
  ;; your code here
  )
</code></pre></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L124">view source</a></div></div><div class="public anchor" id="var-with-bulkhead"><h3>with-bulkhead</h3><h4 class="type">macro</h4><div class="usage"><code>(with-bulkhead opts &amp; body)</code></div><div class="doc"><div class="markdown"><p>Bulkhead block. Only given number of executions is allowed to be executed in parallel.</p>
<pre><code class="clojure">;; create a bulkhead that limit concurrency to 3
(defbulkhead mybh {:concurrency 3})

(with-bulkhead {:bulkhead mybh}
  ;; your task here
  )
</code></pre>
<p>By default it will wait until there is permits available for execution.</p>
<p>You can add <code>max-wait-ms</code> option for change this behavior. If no permits is available when <code>max-wait-ms</code> exceeded, an <code>ex-info</code> will be thrown with <code>ex-data</code> as <code>{:bulkhead true :max-wait-ms wait-timeout}</code></p>
<pre><code class="clojure">(try
  (with-bulkhead {:bulkhead mybh
                  :max-wait-ms 1000}
    ;; your task here
    )
  (catch Exception e
    (is (::bulkhead (ex-data e)))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L491">view source</a></div></div><div class="public anchor" id="var-with-circuit-breaker"><h3>with-circuit-breaker</h3><h4 class="type">macro</h4><div class="usage"><code>(with-circuit-breaker cb &amp; body)</code></div><div class="doc"><div class="markdown"><p>Circuit breaker protected block.</p>
<pre><code class="clj">(require '[diehard.core :as diehard])

(diehard/defcircuitbreaker test-cb {:failure-threshold-ratio [35 50]
                                    :delay-ms 1000})

(diehard/with-circuit-breaker test-cb
  ;; your protected code here
  )
</code></pre>
<p>In this scenario, if the circuit breaker protected code block fails 35 times in 50 executions, as defined in <code>:failure-threshold-ratio</code>, the <code>test-cb</code> is entering into <code>:open</code> state. When circuit breaker is open, all execution requests will be rejected immediately.</p>
<p>After <code>:delay-ms</code>, the circuit breaker will be <code>:half-open</code>. At the moment, 50 execution will be allowed, to test the state to see if it’s recovered. If success, the circuit breaker is back to <code>:closed</code> state. Otherwise, it will be <code>:open</code> again.</p>
<p>The block will throw <code>CircuitBreakerOpenException</code> when the circuit breaker is open and skip execution of inner forms. Otherwise it will return the value or throw the exception raised from inner.</p>
<p>You can always check circuit breaker state with <code>diehard.circuitbreaker/state</code>.</p></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L380">view source</a></div></div><div class="public anchor" id="var-with-rate-limiter"><h3>with-rate-limiter</h3><h4 class="type">macro</h4><div class="usage"><code>(with-rate-limiter opts &amp; body)</code></div><div class="doc"><div class="markdown"><p>Rate Limiter protected block. Code execution in this block is throttled to given rate. Use <code>defratelimiter</code> to define a ratelimiter and use it as option:</p>
<pre><code class="clojure">;; create a rate limiter for 100 executions for second
(defratelimiter myfl {:rate 100})

(with-rate-limiter {:ratelimiter myfl}
  ;; your task here
  )
</code></pre>
<p>By default it will wait forever until there is permits available. You can also specify a <code>max-wait-ms</code> to wait for a given time. If there’s no permits in this period, this block will throw a Clojure <code>ex-info</code>, with <code>ex-data</code> as</p>
<pre><code class="clojure"><br />(try
  (with-rate-limiter {:ratelimiter myfl
                      :max-wait-ms 1000}
    ;; your task here
    )
  (catch Exception e
    (is (:throttled (ex-data e)))))
</code></pre>
<p>If your execution has a greater graininess, you can customize the permits for this execution by setting <code>:permits</code> option.</p>
<pre><code class="clojure">(with-rate-limiter {:ratelimiter myfl
                    :permits (size-of-the-task)}
  ;; your task here
  )
</code></pre></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L431">view source</a></div></div><div class="public anchor" id="var-with-retry"><h3>with-retry</h3><h4 class="type">macro</h4><div class="usage"><code>(with-retry opt &amp; body)</code></div><div class="doc"><div class="markdown"><p>Retry policy protected block. If the return value of or exception thrown from the code block matches the criteria of your retry policy, the code block will be executed again, until it mismatch the retry policy or matches the abort criteria. The block will return the value or throw exception from the last execution. If <code>:circuit-breaker</code> is set, it will throw  <code>CircuitBreakerOpenException</code> when the breaker becomes open.</p>
<h4><a href="#available-options" name="available-options"></a>Available options</h4>
<h5><a href="#retry-criteria" name="retry-criteria"></a>Retry criteria</h5>
<ul>
  <li><code>:retry-when</code> retry when return value is given value</li>
  <li><code>:retry-on</code> retry on given exception / exceptions(vector) were thrown</li>
  <li><code>:retry-if</code> specify a function <code>(fn [return-value
  exception-thrown])</code>, retry if the function returns true</li>
</ul>
<h5><a href="#retry-abortion-criteria" name="retry-abortion-criteria"></a>Retry abortion criteria</h5>
<ul>
  <li><code>:abort-when</code> abort retry when return value is given value</li>
  <li><code>:abort-on</code> abort retry on given exception / exceptions(vector) were  thrown</li>
  <li><code>:abort-if</code> specify a function <code>(fn [return-value
  exception-thrown])</code>, abort retry if the function returns true</li>
  <li><code>:max-retries</code> abort retry when max attempts reached</li>
  <li><code>:max-duration</code> abort retry when duration reached</li>
</ul>
<h5><a href="#delay" name="delay"></a>Delay</h5>
<ul>
  <li><code>:backoff-ms</code> specify a vector <code>[initial-delay-ms max-delay-ms
  multiplier]</code> to control the delay between each retry, the delay for  <strong>n</strong>th retry will be <code>(max (* initial-delay-ms n) max-delay-ms)</code></li>
  <li><code>:delay-ms</code> use constant delay between each retry</li>
  <li><code>:jitter-factor</code> random factor for each delay</li>
  <li><code>:jitter-ms</code> random time <code>(-jitter-ms, jitter-ms)</code> adds to each delay</li>
</ul>
<h5><a href="#use-pre-defined-policy" name="use-pre-defined-policy"></a>Use pre-defined policy</h5>
<p>You can put together all those retry policies in a <code>defretrypolicy</code>. And use <code>:policy</code> option in option map.</p>
<pre><code class="clojure">(diehard/defretrypolicy policy
  {:max-retries 5
   :backoff-ms [1000 10000]})

(diehard/with-retry {:policy policy}
  ;; your code here
  )
</code></pre>
<h5><a href="#retry-listeners" name="retry-listeners"></a>Retry Listeners</h5>
<ul>
  <li><code>:on-abort</code> accepts a function which takes <code>result</code>, <code>exception</code> as  arguments, called when retry aborted</li>
  <li><code>:on-complete</code> accepts a function which takes <code>result</code>, <code>exception</code> as  arguments, called when exiting <code>retry</code> block</li>
  <li><code>:on-failed-attempt</code> accepts a function which takes <code>result</code>,  <code>exception</code> as arguments, called when execution failed (matches  retry criteria)</li>
  <li><code>:on-failure</code> accepts a function which takes <code>result</code>,  <code>exception</code> as arguments, called when existing <code>retry</code> block with  failure (matches retry criteria)</li>
  <li><code>:on-success</code> accepts a function which takes <code>result</code> as arguments,  called when existing <code>retry</code> block with success (mismatches retry  criteria)</li>
  <li><code>:on-retry</code> accepts a function which takes <code>result</code> as arguments,  called when a retry attempted.</li>
</ul>
<h5><a href="#use-predefined-listeners" name="use-predefined-listeners"></a>Use predefined listeners</h5>
<pre><code class="clojure">(diehard/deflistener listener
  {:on-retry (fn [return-value exception-thrown] (println "retried"))})

(diehard/with-retry {:policy policy :listener listener}
  ;; your code here
  )

</code></pre>
<h5><a href="#fallback" name="fallback"></a>Fallback</h5>
<ul>
  <li><code>:fallback</code> fallback value or handler function when retry blocks  exists with failure.</li>
</ul>
<pre><code class="clojure">;; return 5 when attempts failure
(with-retry {:fallback 5}
  ;; ...
  )

;; return fallback handler function result when failed
(with-retry {:fallback (fn [value exception]
                         ;; value: value returned from last attempt
                         ;; exp: exception thrown from last attempt
                         )}
  ;; ...
  )

</code></pre>
<h5><a href="#circuit-breaker" name="circuit-breaker"></a>Circuit breaker</h5>
<ul>
  <li><code>:circuit-breaker</code> a circuit breaker created from <code>defcircuitbreaker</code>. It will work together with retry policy as quit criteria.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/sunng87/diehard/blob/master/src/diehard/core.clj#L208">view source</a></div></div></div></body></html>